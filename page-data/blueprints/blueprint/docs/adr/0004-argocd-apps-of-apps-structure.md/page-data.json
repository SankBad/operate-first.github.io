{"componentChunkName":"component---src-templates-doc-js","path":"/blueprints/blueprint/docs/adr/0004-argocd-apps-of-apps-structure.md","result":{"data":{"site":{"siteMetadata":{"title":"Operate First"}},"mdx":{"id":"17f60bc3-40aa-5be0-8c1d-595a8ba11e53","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"ArgoCD Apps of Apps Structure\"), mdx(\"h2\", null, \"Context and Problem Statement\"), mdx(\"p\", null, \"ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \" manifests are a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#applications\"\n  }), \"declarative way to manage\"), \" ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \" in git. Often times these are manifests that are stored alongside ArgoCD deployment manifests.\"), mdx(\"p\", null, \"This has been fine in the past since we controlled the deployment of ArgoCD and had merge access to the repo where the applications were stored. So if we wanted to onboard a new app, we make a PR with the application manifest and someone on our team would merge it.\"), mdx(\"p\", null, \"But there can be a situation where another team, like cluster-admins or infra, store the ArgoCD deployments in their own repo. \"), mdx(\"p\", null, \"If we applied our current practice, we\\u2019d store our app manifests in this external repo. The problem is that we may not have merge access to this repo, and it wouldn\\u2019t really make much sense for people who manage the infrastructure to also handle PR\\u2019s that don\\u2019t pertain directly to cluster management.\"), mdx(\"h2\", null, \"Considered Options\"), mdx(\"p\", null, \"1) Just have All ArgoCD Manifests in one repo and give Operate-First team members access to infra repo so they can review and merge ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \".\\n2) Have separate teams handle Applications for their Projects in their own Repos, in this way tracking Applications is not a concern for Infra/Operate-first, but rather the individual team belonging to an ArgoCD project\\n3) Have a separate Repo that Operate-First manages, and have a an ArgoCD App of Apps that manages this repo. \"), mdx(\"h2\", null, \"Decision Outcome\"), mdx(\"p\", null, \"Chosen Option \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(3)\"), \". Problems with \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(1)\"), \" have been outlined above. The issues with \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"(3)\"), \" is that there is no way to effectively enforce teams to ensure their App Projects belong to their team\\u2019s project (this is further described below). \"), mdx(\"p\", null, \"The Proposed Solution is captured by this diagram: \"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://user-images.githubusercontent.com/10904967/99705533-d8aac380-2a67-11eb-88e9-b63582271994.png\",\n    \"alt\": \"image\"\n  }))), mdx(\"p\", null, \"The idea here is that all our operate-first/team-1/team-2/\\u2026/team-n ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \" would go in the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"opf-argocd-apps\"), \" repo. Then we\\u2019d have an App of Apps i.e. the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"OPF Parent App\"), \" that manages all these apps. This way we can add new applications declaratively to ArgoCD without having to make PR\\u2019s to the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Infra Repo\"), \" (e.g. \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"moc-cnv-sandbox\"), \"). Operate-first admins would manage the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"opf-argocd-app\"), \" repo. Any other ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \" that manage cluster resources like \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"clusterrolebindings\"), \" or operator \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"subscriptions\"), \" etc. can remain in the infra repo since that\\u2019s a concern for cluster admins. We would direct any \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"user\"), \" that wants to use ArgoCD to manage their apps to add their ArgoCD \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Applications\"), \" to the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"opf-argocd-apps\"), \" repo. \"), mdx(\"h3\", null, \"Positive Consequences\"), mdx(\"ul\", {\n    \"className\": \"pf-c-list\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Infrastructure/cluster-admins are not bombarded with PR\\u2019s for ArgoCD App onboarding \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"OperateFirst maintainers can handle the PR\\u2019s unhindered \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \\u201COPF-ArgoCD-Apps\\u201D repo can be leveraged by CRC/Quicklab/Other OCP Clusters to quickly setup ArgoCD ODH/Thoth/etc. Applications. \")), mdx(\"h3\", null, \"Negative Consequences\"), mdx(\"p\", null, \"Biggest concern here is that there is no way to automatically enforce that Applications in \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"opf-argocd-apps\"), \" repo \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"belong\"), \" to the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Operate First\"), \" ArgoCD project (see diagaram). \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Why is this a problem?\"), \" Because we use ArgoCD projects to restrict what types of resources applications \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"in that project can deploy\"), \". For example ArgoCD apps in the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Infra Apps\"), \" project in the diagram can deploy \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"clusterrolebinding\"), \", \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"operators\"), \", etc. So while \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"OPF Parent App\"), \" cannot deploy \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"clusterrolebindings\"), \" because it belongs to the \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Operate First\"), \" ArgoCD project, it could deploy another ArgoCD application that belongs to \", mdx(\"code\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Infra apps\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"that ArgoCD app\"), \" could deploy clusterrolebindings. \"), mdx(\"p\", null, \"You can read more about this \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/argoproj/argo-cd/issues/3045\"\n  }), \"issue here\"), \". The individual there used admission hooks to get around this but I don\\u2019t think we want to go there just yet. My suggestion is we begin by enforcing this at the PR level, and transition to maybe catching this in CI until there\\u2019s a proper solution upstream. \"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","description":null}}},"pageContext":{"id":"17f60bc3-40aa-5be0-8c1d-595a8ba11e53","slug":"docs/adr/0004-argocd-apps-of-apps-structure"}},"staticQueryHashes":["117426894","3000541721","3753692419"]}