{"componentChunkName":"component---src-templates-doc-js","path":"/aici/publish/failure-type-classification-with-the-testgrid-data-project-doc","result":{"data":{"site":{"siteMetadata":{"title":"Operate First"}},"mdx":{"id":"ae756a57-6b4a-5f46-a7be-e4d228b9e4dc","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Failure type classification with the TestGrid data\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Sanket Badhe, Michael Clifford and Marcel Hild\"), \",  \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2020-10-27 v0.1.0-dev\")), mdx(\"h2\", null, \"Overview\"), mdx(\"p\", null, \"In continuous integration (CI) project workflow, developers frequently integrate code into a shared repository. Each integration can then be verified by an automated build and numerous different automated tests. Whenever a failure occurs in a test, developers manually need to analyze failures. Failures in the build can be a legitimate failure or due to some other issues like infrastructure flake, install flake, flaky test, etc. SME can analyze the TestGrid data and determine if failures are legitimate or not. However, it takes a lot of manual effort and reduces the productivity of a team.\"), mdx(\"p\", null, \"In this project, our objective is to automate the failure type classification task with the Testgrid data. As we don\\u2019t have labeled data to address this problem, we will focus on unsupervised learning methods and heuristics. Figure 1 shows the TestGrid data with different patterns to analyze the type of failure.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/21de8/annotated_testgrid.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"45.94594594594595%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAAB7ElEQVQozzXOaW+aAADGcb/3Xm5ru5geE8VOpeLwaEvtpiA6G6wHqOCJJ4KIonihWNdkzUzKBjteP/nl+dteDWOjbTerta7vt9r39eJpvXrS1vuFup3PtKWqLxc7TXvWtL22edb1F333Y7t72e9/Gq+/bIZhKIoiy/JMnTakclUudqVaTcxXxXxLZtlRlhWzLZHpDSpdnq1JdF2ka+1spffYHJYtzDDMQ/qBzJEIcxHsOb91wkjl3W39JF4FvJU3UPM9xvnJMpIuB8JtIFIHguTRVeEt2nBbuFAo4BiOJbEQd4n2PaVlJsA7g4KbmKBg5xjqnefUVEOjWDVxJwfux8j1yAcLADG9szBN0ybGU3iIc3/tuuh5OsA7ggJozu7uCdQ+zUxxdkoy4/itdBUdwmHhk7//ER/fWJiiqb84zIFoEyjOCJgHEAFMTlB359jHnz3OidyQKI1jqARFJTgiemDe8R9TFBbH8CQW5lyh6kVpmoQHFjazzWdf/yyjJmqrHKv8eR7Bn9uAr2nH5et/2Qk8YWV3LmN9V1FJBgSnla1Y2eZzRiWqyyyjxNGRPyZ6o9QHtGIvTO5th8Mhn8+bz4kkHmg6wwMwM4pD3CncdcSGIVfryNOyp8bR3DRFKlhk4LkZeJE+CHXOv4jIbyxpnDyO+xTxAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"image alt text\",\n    \"title\": \"image alt text\",\n    \"src\": \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/fcda8/annotated_testgrid.png\",\n    \"srcSet\": [\"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/12f09/annotated_testgrid.png 148w\", \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/e4a3f/annotated_testgrid.png 295w\", \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/fcda8/annotated_testgrid.png 590w\", \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/efc66/annotated_testgrid.png 885w\", \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/c83ae/annotated_testgrid.png 1180w\", \"/operate-first.github.io/static/e86fd43a7e305b3a6f7a94499d9032e5/21de8/annotated_testgrid.png 2436w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \" Figure 1: Different type of failures in TestGrid\"), mdx(\"p\", null, \" In the following section, we discuss the different patterns in more detail.\"), mdx(\"ul\", {\n    \"className\": \"pf-c-list\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Rows with red interspersed with green: This usually means a flakey test.  Flakey tests pass and fail across multiple runs over a certain period of time. We can trigger this test behavior by using the concept of edge. Edge is the transition of a particular test case from pass to fail on the successive run. We can model edges using a different technique to detect a flakey test.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Rows with solid red chunks: This behavior is almost always a regression either in the test or the product.  We can analyze each row to check continuous red cells for detecting install flakes.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Rows with solid red chunks and white to the right: This behavior usually means a new test was added that is failing when running in the release job. For each cell, we will check if there exist all failed test cases to the left and all passing test cases to the right. If there exists this pattern, we will trigger this error.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Repeating vertical red bars: This behavior usually means the subsystem has a bug, and we will find a set of rows that all fail together on the same runs. For this failure type we can also analyze each column to check for continuous red cells to detect subsystem bugs.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Failure waterfall:  If there are meandering failures moving from bottom to top, right to the left, this almost always means Infrak flake. We can generate convolutional filters manually to detect Failure waterfall patterns. If it\\u2019s hectic to encode all the patterns manually, we can also develop a method to create convolution filters to detect \\u2018Failure waterfall\\u2019 patterns automatically.\"))), mdx(\"p\", null, \"If this project is successful, we will develop a tool to automatically analyze the TestGrid data. This tool will perform failure type classification with the Testgrid data to address an existing manual process executed by subject matter experts. Using the tool, the developers can focus on real issues and become more productive. Furthermore, we will provide insights about overall statistics about failures so that test developers can improve on existing test suites.\"), mdx(\"h3\", null, \"A. Problem Statement\"), mdx(\"p\", null, \"Given a TestGrid, we want to classify/detect different failure patterns occurring over a certain period of time. In the later part, we will aggregate the results to conclude about the primary reasons behind failures for each release.\"), mdx(\"h3\", null, \"B. Checklist for project completion\"), mdx(\"ol\", {\n    \"className\": \"pf-c-list\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A notebooks that shows classification and analysis of different types of test failures on TestGrid data.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Jupyterhub image to reproduce the results.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Public blog explaining analysis and results.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Results hosted for SME to review\"))), mdx(\"h3\", null, \"C. Provide a solution in terms of human actions to confirm if the task is within the scope of automation through AI.\"), mdx(\"p\", null, \"Without AI and automation tooling, SME will need to go to TestGrid data of a particular release and look at the failures. An SME will determine if that failure is following any of the patterns that we have discussed in earlier sections. Based on detected patterns, an SME tries to determine the reason behind failure.\"), mdx(\"h3\", null, \"D. Outline a path to operationalization.\"), mdx(\"p\", null, \"Once we have notebooks ready, we will build a Notebook-based Pipeline using Elyra. The results will be stored in S3. We can then use Superset as our dashboard and visualization tool, which SME/developers can access and give feedback. If the tool is deemed useful, we could also look into integrating it with the existing TestGrid project.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","description":null}}},"pageContext":{"id":"ae756a57-6b4a-5f46-a7be-e4d228b9e4dc","slug":"publish/failure-type-classification-with-the-testgrid-data-project-doc"}},"staticQueryHashes":["117426894","3000541721","3753692419"]}